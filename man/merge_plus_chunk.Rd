% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/merge_plus_chunk.R
\name{merge_plus_chunk}
\alias{merge_plus_chunk}
\title{merge_plus_chunk}
\usage{
merge_plus_chunk(data1, data2, by = NULL, by.x = by, by.y = by,
  suffixes = c(".x", ".y"), check_merge = TRUE, unique_key_1, unique_key_2,
  match_type = "exact", amatch.args = list(method = "jw", p = 0.1, maxDist =
  0.05, matchNA = FALSE), score_settings = NULL, filter = NULL,
  filter.args = list(), evaluate = match_evaluate, evaluate.args = list(),
  chunk = NULL)
}
\arguments{
\item{data1}{data.frame. First to-merge dataset.}

\item{data2}{data.frame. Second to-merge dataset.}

\item{by}{character string. Variables to merge on (common across data 1 and data 2). See \code{merge}}

\item{by.x}{character string. Variable to merge on in data1. See \code{merge}}

\item{by.y}{character string. Variable to merge on in data2. See \code{merge}}

\item{suffixes}{character vector with length==2. Suffix to add to like named variables after the merge. See \code{merge}}

\item{check_merge}{logical. Checks that your unique_keys are indeed unique, and prevents merge from running if merge would result in data.frames larger than 5 million rows}

\item{unique_key_1}{character vector. Primary key of data1 that uniquely identifies each row (can be multiple fields)}

\item{unique_key_2}{character vector. Primary key of data2 that uniquely identifies each row (can be multiple fields)}

\item{score_settings}{list. score settings. See vingette matchscore}

\item{filter}{function or numeric. Filters a merged data1-data2 dataset. If a function, should take in
a data.frame (data1 and data2 merged by name1 and name2) and spit out a trimmed verion
of the data.frame (fewer rows). Think of this function as applying other conditions
to matches, other than a match by name. The first argument of filter should be the data.frame.
If numeric, will drop all observations with a matchscore lower than or equal to filter.}

\item{filter.args}{list. Arguments passed to filter, if a function}

\item{evaluate}{function to evalute merge_plus match}

\item{evaluate.args}{list. Arguments passed to evaluate}

\item{chunk}{character vector. Columns by which to group by for merging. All columns}

\item{match_type.}{string. If 'exact', match is exact, if 'fuzzy', match is fuzzy.}

\item{amatch.args.}{additional arguments for amatch, to be used if match_type = 'fuzzy'. Suggested defaults provided. (see amatch, method='jw')}
}
\value{
list with matches, filtered matches (if applicable), data1 and data2 minus matches, and match evaluation
}
\description{
merge two datasets, plus.
}
\examples{
x <- data.frame('id' = 1:16, "a" = 10:25, "b" = 20:35, "c" = 30:45,
  "d" = rep(c("one", "two", "three", "four"), 4))
y <- data.frame('id' = 17:32, "a" = 10:25, "b" = c(20:30, 32:36), "c" = 30:45,
 "d" = rep(c("one", "two", "three", "four"), 4))
merge_plus_chunk(x, y, by = c('b'), unique_key_1 = 'id', unique_key_2 = 'id', chunk = c("a", "d"))


}
\seealso{
match_evaluate
}
